# Progress Tracker

## DSA
- [ ] Complete Git & GitHub Course
- [ ] Introduction to Programming
  - - [ ] Types of languages
  - - [ ] Memory management
- [ ] Flow of the program
  - - [ ] Flowcharts 
  - - [ ] Pseudocode
- [x] Introduction to Java
  - - [x] Introduction
  - - [x] How it works
  - - [x] Setup Installation
  - - [x] Input and Output in Java
  - - [x] Conditionals & Loops in Java
   - - [x] if else
   - - [x] loops
   - - [x] Switch statements
  - - [x] Data types
  - - [x] Coding best practices
- [x] Functions
  - - [x] Introduction
  - - [x] Scoping in Java
  - - [x] Shadowing 
  - - [x] Variable Length Arguments
  - - [x] Overloading
- [x] Arrays
  - - [x] Introduction 
  - - [x] Memory management 
  - - [x] Input and Output
  - - [x] ArrayList Introduction
  - - [x] Sorting 
   - - [x] Insertion Sort
    - - [x] Selection Sort
    - - [x] Bubble Sort
    - - [x] Cyclic Sort (Merge sort etc after recursion)

Shell Sort
Cocktail Sort
Comb Sort
Gnome Sort
Odd-Even Sort
Pancake Sort
Stooge Sort
Cocktail Sort
Bead Sort
Pigeonhole Sort
Bitonic Sort
Bogo Sort
Cycle Sort

Bubble Sort :-  Time Complexity: O(n^2)  Space Complexity: O(1)
Selection Sort   Time Complexity: O(n^2)  Space Complexity: O(1)
Insertion Sort  Time Complexity: O(n^2) (worst case), O(n) (best case)  Space Complexity: O(1)
Merge Sort  Time Complexity: O(n log n)  Space Complexity: O(n)
Quick Sort  Time Complexity: O(n log n) (average case), O(n^2) (worst case)  Space Complexity: O(log n) (average case), O(n) (worst case)
Heap Sort  Time Complexity: O(n log n)  Space Complexity: O(1)
Counting Sort  Time Complexity: O(n+k) (where k is the range of the input)  Space Complexity: O(n+k)
Radix Sort   Time Complexity: O(d(n+k)) (where d is the number of digits in the largest number, and k is the range of the input)   Space Complexity: O(n+k)
Bucket Sort   Time Complexity: O(n+k) (where k is the number of buckets)  Space Complexity: O(n+k)



  - [ ] Searching 
   - - [ ] Linear Search
    - - [ ] Sentinel Linear Search
    - - [ ] Binary Search
    - - [ ] Modified Binary Search
    - - [ ] Binary Search Interview questions
    - - [ ] Binary Search on 2D Arrays
    - - [ ] Jump search
    - - [ ] Meta Binary Search | One-Sided Binary Search
    - - [ ] Ternary Search
    - - [ ] Fibonacci Search
    - - [ ] The Ubiquitous Binary Search
    - - [ ] Sublist search (Search a linked list in another list)
    - - [ ]  substring search
    - - [ ]  unbounded binary search
    - - [ ]  interval search
    - - [ ]  The Bidirectional Search
    - - [ ]  Uniform Cost Search
    - - [ ]  Greedy Best First Search
    - - [ ]  Interpolation search
    - - [ ]  Exponential search
    - - [ ]  Depth-first search (DFS)
    - - [ ]  Breadth-first search (BFS)
    - - [ ]  Best-first search
    - - [ ]  A* search
    - - [ ]  Hill climbing
    - - [ ]  Beam search
    - - [ ]  Simulated annealing
    - - [ ]  Genetic algorithms
    - - [ ]  Ant colony optimization
    - - [ ] Particle Swarm Optimization
- [x] Pattern questions
- [x] Strings
    - [x] Introduction
    - [x] How Strings work
    - [x] Comparison of methods
    - [x] Operations in Strings
    - [x] StringBuilder in java
- [x] Maths for DSA
    - - [x] Introduction
    - - [x] Complete Bitwise Operators
    - - [x] Prime numbers
    - - [x] HCF / LCM
    - - [x] Sieve of Eratosthenes
    - - [x] Newton's Square Root Method
    - - [x] Number Theory
    - - [x] Euclidean algorithm
- [x] Space and Time Complexity Analysis
    - - [x] Introduction
    - - [x] Comparion of various cases
    - - [x] Solving Linear Recurrence Relations
    - - [x] Solving Divide and Conquer Recurrence Relations
    - - [x] Big-O, Big-Omega, Big-Theta Notations
    - - [x] Get equation of any relation easily - best and easiest approach
    - - [x] Complexity discussion of all the problems we do
    - - [x] Space Complexity 
    - - [x] Memory Allocation of various languages
    - - [x] NP Completeness and Hardness
- [x] Recursion
    - - [x] Introduction
    - - [x] Why recursion?
    - - [x] Flow of recursive programs - stacks
    - - [x] Convert recursion to iteration
    - - [x] Tree building of function calls
    - - [x] Tail recursion
    - - [x] Sorting:
     - - [x] Merge Sort
      - - [x] Quick Sort
    - - [x] Backtracking
     - - [x] Sudoku Solver
      - - [x] N-Queens
      - - [x] N-Knights
      - - [x] Maze problems
    - - [x] Recursion String Problems
    - - [x] Recursion Array Problems
    - - [x] Recursion Pattern Problems
    - - [x] Subset Questions
    - - [x] Recursion - Permutations, Dice Throws etc Questions
- [x] Object Oriented Programming
    - - [x] Introduction
    - - [x] Classes & its instances
    - - [x] this keyword in Java
    - - [x] Properties
     - - [x] Inheritance
      - - [x] Abstraction
      - - [x] Polymorphism
      - - [x] Encapsulation
    - - [x] Overloading & Overriding
    - - [x] Static & Non-Static
    - - [x] Access Control
    - - [x] Interfaces
    - - [x] Abstract Classes
    - - [x] Singleton Class
    - - [x] final, finalize, finally
    - - [x] Exception Handling
- [x] Linked List
    - - [] Introduction
    - - [x] Singly and Doubly Linked List
    - - [x] Circular Linked List
    - - [x] Fast and slow pointer
    - - [x] Cycle Detection
    - - [x] Reversing of LinekdList
    - - [x] Linked List Interview questions
    
Insertion at the beginning: A new node is added to the beginning of the list. This operation is also called push.
Insertion at the end: A new node is added to the end of the list. This operation is also called append.
Insertion at a specific position: A new node is added at a specific position in the list.
Deletion from the beginning: The first node in the list is removed.
Deletion from the end: The last node in the list is removed.
Deletion from a specific position: A node at a specific position in the list is removed.
Traversal: The list is traversed, i.e., all the nodes are visited one by one.
Searching: A specific element is searched in the list.
Length: The length of the list is calculated.
Concatenation: Two linked lists are merged together to form a single linked list.
Reversal: The order of the nodes in the list is reversed.
Sorting: The elements in the list are arranged in a sorted order.
Find the length of a linked list - We can find the number of elements in the linked list by traversing the list and counting the number of nodes.
Check if a linked list is empty - We can check if a linked list is empty by checking if the head node is null.
Swapping: Exchanging the positions of two nodes in the linked list.
    Create a linked list - A linked list can be created by dynamically allocating memory for nodes and linking them together.
    Splitting: Dividing a linked list into two separate lists.
    Circularization: This operation is used to convert a singly linked list into a circular linked list by making the last node point to the first node.
    Counting: This operation is used to count the number of nodes in the linked list.
    
    Cycle Detection: Write a function that detects if a linked list has a cycle or not.
Intersection Detection: Write a function that detects if two linked lists intersect and returns the intersecting node.
Palindrome Detection: Write a function that detects if a linked list is a palindrome.
Duplicate Removal: Write a function that removes duplicates from a linked list.
Middle Element: Write a function that finds the middle element of a linked list.
Nth Element from End: Write a function that finds the Nth element from the end of a linked list.
Addition: Write a function that adds two numbers represented as linked lists and returns the result as a linked list.
Subtraction: Write a function that subtracts two numbers represented as linked lists and returns the result as a linked list.
Multiplication: Write a function that multiplies two numbers represented as linked lists and returns the result as a linked list.

Find the middle node of the linked list.
Determine if the linked list is circular (i.e. has a cycle).
Remove any cycles in the linked list.
Implement a LRU cache using a doubly linked list and a hash map.
Flatten a nested linked list and return it as a single linked list.
Write a program to convert a binary tree into a linked list.

Implement a function to clone a linked list with arbitrary pointers.



- [x] Stacks & Queues
    - - [x] Introduction
    - - [x] Interview problems
    - - [x] Push efficient
    - - [x] Pop efficient
    - - [x] Queue using Stack and Vice versa
    - - [x] Circular Queue
- [ ] Dynamic Programming
    - - [ ] Introduction
    - - [ ] Recursion + Recursion DP + Iteration + Iteration Space Optimized
    - - [ ] Complexity Analysis
    - - [ ] 0/1 Knapsack
    - - [ ] Subset Questions
    - - [ ] DP on Grids
    - - [ ] LC Questions on Above topics
    - - [ ] Unbounded Knapsack
    - - [ ] Subseq questions
    - - [ ] String DP
- [ ] Trees
    - - [ ] Introduction
    - - [ ] Binary Trees
    - - [ ] Recursive Preorder, Inorder, Postorder Traversals
    - - [ ] Iterative Preorder, Inorder, Postorder Traversals
    - - [ ] LC Questions
    - - [ ] DFS
    - - [ ] BFS  
    - - [ ] Morris Traversal `O(1) Space`
    - - [ ] Binary Search Trees
    - - [ ] LC Questions
    - - [ ] AVL Trees
    - - [ ] Segment Tree
    - - [ ] Fenwick Tree / Binary Indexed Tree
- [ ] Heaps
    - - [ ] Introduction
    - - [ ] Theory
    - - [ ] Priority Queue
    - - [ ] Two Heaps Method
    - - [ ] k-way merge
    - - [ ] top k elements
    - - [ ] interval problems
- [ ] Hashmaps
    - - [ ] Introduction
    - - [ ] Theory - how it works
    - - [ ] Comparisons of various forms
    - - [ ] Limitations and how to solve
    - - [ ] Map using LinkedList
    - - [ ] Map using Hash
    - - [ ] Chaining
    - - [ ] Probing
    - - [ ] Huffman-Encoder
- [ ] Tries
    - - [ ] Introduction
    - - [ ] Theory - how it works
    - - [ ] Applications
    - - [ ] Insert and Search
    - - [ ] GFG articles and Questions
    - - [ ] Interview Questions
- [ ] Graphs
    - - [ ] Introduction
    - - [ ] BFS
    - - [ ] DFS
    - - [ ] Union find
    - - [ ]   Degree
    - - [ ] Working with graph components
    - - [ ] Bipartite Graph
    - - [ ] LC Questions
    - - [ ] Minimum Spanning Trees
    - - [ ] Kruskal Algorithm
    - - [ ] Prims Algorithm
    - - [ ] Dijkstra’s shortest path algorithm
    - - [ ] Topologically sort the vertices of a directed acyclic graph (DAG).
    - - [ ] Kahn's Algorithm
    - - [ ] Bellman ford
    - - [ ] A* pathfinding Algorithm
              Create an empty graph with a given number of vertices.
              Add a new vertex to the graph.
              Add a new edge between two vertices in the graph.
              Remove a vertex from the graph.
              Remove an edge between two vertices in the graph.
              Check if a given vertex is in the graph.
              Get the list of all vertices in the graph.
              Get the list of all edges in the graph.
              Get the neighbors of a given vertex in the graph.
              Check if there is an edge between two given vertices in the graph.
              Check if the graph is connected (i.e., there is a path between every pair of vertices).
              Detect cycles in the graph.
              Check if edge exists: Check if an edge between two vertices is present in the graph.
              Get degree of a vertex: Retrieve the number of edges incident to a given vertex.
- [ ] Greedy Algorithms
    - - [ ] Introduction
    - - [ ] Applications
    - - [ ] LC,GFG Questions
    - - [ ] Interview Questions
 - [ ] Bloom Filters
 - [ ] Matrix Operations
      -- [ ] Addition of matrix
     -- [ ] Substraction of matrix
     -- [ ] Multiplication of matrix
     -- [ ] Division of matrix
     -- [ ] inverse of matrix
     -- [ ] Adjoint  of matrix
     -- [ ] transpose of matrix
     -- [ ] Scalar Multiplication: Multiplying a matrix by a scalar value
     -- [ ] Determinant: Calculating a scalar value that can be used to determine invertibility and other properties of a square matrix
     -- [ ] Trace: The sum of the diagonal entries of a square matrix
     -- [ ] Rank: The number of linearly independent rows or columns in a matrix
     -- [ ] Eigenvalues and Eigenvectors: A scalar and corresponding non-zero vector that satisfy a certain equation
     -- [ ] Diagonalization: Finding a diagonal matrix that is similar to a given matrix
     -- [ ] LU Factorization: Factorizing a matrix into a lower triangular matrix and an upper triangular matrix
     -- [ ] QR Factorization: Factorizing a matrix into an orthogonal matrix and an upper triangular matrix
     -- [ ]  Singular Value Decomposition (SVD): Factorizing a matrix into three matrices that describe the matrix's rank and singular values. 
     -- [ ] Orthogonalization
     -- [ ] Null space
     -- [ ] Row echelon form
     -- [ ] Reduced row echelon form
     -- [ ] Gram-Schmidt process
     -- [ ] Projection
     -- [ ] Reflection
     -- [ ] Rotation
     -- [ ] Cross product
     -- [ ] Dot product

### Advanced concepts apart from interviews 
- [ ] Fast IO
- [ ] File handling
- [ ] Bitwise + DP
- [ ] Extended Euclidean algorithm
- [ ] Modulo Multiplicative Inverse
- [ ] Linear Diophantine Equations
- [ ] Matrix Exponentiation
- [ ] Mathematical Expectation
- [ ] Catalan Numbers
- [ ] Fermat’s Theorem
- [ ] Wilson's Theorem
- [ ] Euler's Theorem
- [ ] Lucas Theorem
- [ ] Chinese Remainder Theorem
- [ ] Euler Totient
- [ ] NP-Completeness
- [ ] Multithreading
- [ ] Fenwick Tree / Binary Indexed Tree
- [ ] Square Root Decomposition
