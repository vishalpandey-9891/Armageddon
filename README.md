# Progress Tracker

## DSA
- [ ] Complete Git & GitHub Course
- [ ] Introduction to Programming
  - - [ ] Types of languages
  - - [ ] Memory management
- [ ] Flow of the program
  - - [ ] Flowcharts 
  - - [ ] Pseudocode
- [x] Introduction to Java
  - - [x] Introduction
  - - [x] How it works
  - - [x] Setup Installation
  - - [x] Input and Output in Java
  - - [x] Conditionals & Loops in Java
   - - [x] if else
   - - [x] loops
   - - [x] Switch statements
  - - [x] Data types
  - - [x] Coding best practices
- [x] Functions
  - - [x] Introduction
  - - [x] Scoping in Java
  - - [x] Shadowing 
  - - [x] Variable Length Arguments
  - - [x] Overloading
- [x] Arrays
  - - [x] Introduction 
  - - [x] Memory management 
  - - [x] Input and Output
  - - [x] ArrayList Introduction
  - - [x] Sorting 
   - - [x] Insertion Sort
    - - [x] Selection Sort
    - - [x] Bubble Sort
    - - [x] Cyclic Sort (Merge sort etc after recursion)
  - [ ] Searching 
   - - [ ] Linear Search
    - - [ ] Sentinel Linear Search
    - - [ ] Binary Search
    - - [ ] Modified Binary Search
    - - [ ] Binary Search Interview questions
    - - [ ] Binary Search on 2D Arrays
    - - [ ] Jump search
    - - [ ] Meta Binary Search | One-Sided Binary Search
    - - [ ] Ternary Search
    - - [ ] Fibonacci Search
    - - [ ] The Ubiquitous Binary Search
    - - [ ] Sublist search (Search a linked list in another list)
    - - [ ]  substring search
    - - [ ]  unbounded binary search
    - - [ ]  interval search
    - - [ ]  The Bidirectional Search
    - - [ ]  Uniform Cost Search
    - - [ ]  Greedy Best First Search
    - - [ ]  Interpolation search
    - - [ ]  Exponential search
    - - [ ]  Depth-first search (DFS)
    - - [ ]  Breadth-first search (BFS)
    - - [ ]  Best-first search
    - - [ ]  A* search
    - - [ ]  Hill climbing
    - - [ ]  Beam search
    - - [ ]  Simulated annealing
    - - [ ]  Genetic algorithms
    - - [ ]  Ant colony optimization
    - - [ ] Particle Swarm Optimization
- [x] Pattern questions
- [x] Strings
    - [x] Introduction
    - [x] How Strings work
    - [x] Comparison of methods
    - [x] Operations in Strings
    - [x] StringBuilder in java
- [x] Maths for DSA
    - - [x] Introduction
    - - [x] Complete Bitwise Operators
    - - [x] Prime numbers
    - - [x] HCF / LCM
    - - [x] Sieve of Eratosthenes
    - - [x] Newton's Square Root Method
    - - [x] Number Theory
    - - [x] Euclidean algorithm
- [x] Space and Time Complexity Analysis
    - - [x] Introduction
    - - [x] Comparion of various cases
    - - [x] Solving Linear Recurrence Relations
    - - [x] Solving Divide and Conquer Recurrence Relations
    - - [x] Big-O, Big-Omega, Big-Theta Notations
    - - [x] Get equation of any relation easily - best and easiest approach
    - - [x] Complexity discussion of all the problems we do
    - - [x] Space Complexity 
    - - [x] Memory Allocation of various languages
    - - [x] NP Completeness and Hardness
- [x] Recursion
    - - [x] Introduction
    - - [x] Why recursion?
    - - [x] Flow of recursive programs - stacks
    - - [x] Convert recursion to iteration
    - - [x] Tree building of function calls
    - - [x] Tail recursion
    - - [x] Sorting:
     - - [x] Merge Sort
      - - [x] Quick Sort
    - - [x] Backtracking
     - - [x] Sudoku Solver
      - - [x] N-Queens
      - - [x] N-Knights
      - - [x] Maze problems
    - - [x] Recursion String Problems
    - - [x] Recursion Array Problems
    - - [x] Recursion Pattern Problems
    - - [x] Subset Questions
    - - [x] Recursion - Permutations, Dice Throws etc Questions
- [x] Object Oriented Programming
    - - [x] Introduction
    - - [x] Classes & its instances
    - - [x] this keyword in Java
    - - [x] Properties
     - - [x] Inheritance
      - - [x] Abstraction
      - - [x] Polymorphism
      - - [x] Encapsulation
    - - [x] Overloading & Overriding
    - - [x] Static & Non-Static
    - - [x] Access Control
    - - [x] Interfaces
    - - [x] Abstract Classes
    - - [x] Singleton Class
    - - [x] final, finalize, finally
    - - [x] Exception Handling
- [x] Linked List
    - - [] Introduction
    - - [x] Singly and Doubly Linked List
    - - [x] Circular Linked List
    - - [x] Fast and slow pointer
    - - [x] Cycle Detection
    - - [x] Reversing of LinekdList
    - - [x] Linked List Interview questions
- [x] Stacks & Queues
    - - [x] Introduction
    - - [x] Interview problems
    - - [x] Push efficient
    - - [x] Pop efficient
    - - [x] Queue using Stack and Vice versa
    - - [x] Circular Queue
- [ ] Dynamic Programming
    - - [ ] Introduction
    - - [ ] Recursion + Recursion DP + Iteration + Iteration Space Optimized
    - - [ ] Complexity Analysis
    - - [ ] 0/1 Knapsack
    - - [ ] Subset Questions
    - - [ ] DP on Grids
    - - [ ] LC Questions on Above topics
    - - [ ] Unbounded Knapsack
    - - [ ] Subseq questions
    - - [ ] String DP
- [ ] Trees
    - - [ ] Introduction
    - - [ ] Binary Trees
    - - [ ] Recursive Preorder, Inorder, Postorder Traversals
    - - [ ] Iterative Preorder, Inorder, Postorder Traversals
    - - [ ] LC Questions
    - - [ ] DFS
    - - [ ] BFS  
    - - [ ] Morris Traversal `O(1) Space`
    - - [ ] Binary Search Trees
    - - [ ] LC Questions
    - - [ ] AVL Trees
    - - [ ] Segment Tree
    - - [ ] Fenwick Tree / Binary Indexed Tree
- [ ] Heaps
    - - [ ] Introduction
    - - [ ] Theory
    - - [ ] Priority Queue
    - - [ ] Two Heaps Method
    - - [ ] k-way merge
    - - [ ] top k elements
    - - [ ] interval problems
- [ ] Hashmaps
    - - [ ] Introduction
    - - [ ] Theory - how it works
    - - [ ] Comparisons of various forms
    - - [ ] Limitations and how to solve
    - - [ ] Map using LinkedList
    - - [ ] Map using Hash
    - - [ ] Chaining
    - - [ ] Probing
    - - [ ] Huffman-Encoder
- [ ] Tries
    - - [ ] Introduction
    - - [ ] Theory - how it works
    - - [ ] Applications
    - - [ ] Insert and Search
    - - [ ] GFG articles and Questions
    - - [ ] Interview Questions
- [ ] Graphs
    - - [ ] Introduction
    - - [ ] BFS
    - - [ ] DFS
    - - [ ] Working with graph components
    - - [ ] Bipartite Graph
    - - [ ] LC Questions
    - - [ ] Minimum Spanning Trees
    - - [ ] Kruskal Algorithm
    - - [ ] Prims Algorithm
    - - [ ] Dijkstra’s shortest path algorithm
    - - [ ] Topologically sort the vertices of a directed acyclic graph (DAG).
    - - [ ] Kahn's Algorithm
    - - [ ] Bellman ford
    - - [ ] A* pathfinding Algorithm
              Create an empty graph with a given number of vertices.
              Add a new vertex to the graph.
              Add a new edge between two vertices in the graph.
              Remove a vertex from the graph.
              Remove an edge between two vertices in the graph.
              Check if a given vertex is in the graph.
              Get the list of all vertices in the graph.
              Get the list of all edges in the graph.
              Get the neighbors of a given vertex in the graph.
              Check if there is an edge between two given vertices in the graph.
              Check if the graph is connected (i.e., there is a path between every pair of vertices).
              Detect cycles in the graph.
              Check if edge exists: Check if an edge between two vertices is present in the graph.
              Get degree of a vertex: Retrieve the number of edges incident to a given vertex.
- [ ] Greedy Algorithms
    - - [ ] Introduction
    - - [ ] Applications
    - - [ ] LC,GFG Questions
    - - [ ] Interview Questions
 - [ ] Bloom Filters
 - [ ] Matrix Operations
     -- [ ] Addition of matrix
     -- [ ] Substraction of matrix
     -- [ ] Multiplication of matrix
     -- [ ] Division of matrix
     -- [ ] inverse of matrix
     -- [ ] Adjoint  of matrix
     -- [ ] transpose of matrix
     -- [ ] Scalar Multiplication: Multiplying a matrix by a scalar value
     -- [ ] Determinant: Calculating a scalar value that can be used to determine invertibility and other properties of a square matrix
     -- [ ] Trace: The sum of the diagonal entries of a square matrix
     -- [ ] Rank: The number of linearly independent rows or columns in a matrix
     -- [ ] Eigenvalues and Eigenvectors: A scalar and corresponding non-zero vector that satisfy a certain equation
     -- [ ] Diagonalization: Finding a diagonal matrix that is similar to a given matrix
     -- [ ] LU Factorization: Factorizing a matrix into a lower triangular matrix and an upper triangular matrix
     -- [ ] QR Factorization: Factorizing a matrix into an orthogonal matrix and an upper triangular matrix
     -- [ ]  Singular Value Decomposition (SVD): Factorizing a matrix into three matrices that describe the matrix's rank and singular values. 
     -- [ ] Orthogonalization
     -- [ ] Null space
     -- [ ] Row echelon form
     -- [ ] Reduced row echelon form
     -- [ ] Gram-Schmidt process
     -- [ ] Projection
     -- [ ] Reflection
     -- [ ] Rotation
     -- [ ] Cross product
     -- [ ] Dot product

### Advanced concepts apart from interviews 
- [ ] Fast IO
- [ ] File handling
- [ ] Bitwise + DP
- [ ] Extended Euclidean algorithm
- [ ] Modulo Multiplicative Inverse
- [ ] Linear Diophantine Equations
- [ ] Matrix Exponentiation
- [ ] Mathematical Expectation
- [ ] Catalan Numbers
- [ ] Fermat’s Theorem
- [ ] Wilson's Theorem
- [ ] Euler's Theorem
- [ ] Lucas Theorem
- [ ] Chinese Remainder Theorem
- [ ] Euler Totient
- [ ] NP-Completeness
- [ ] Multithreading
- [ ] Fenwick Tree / Binary Indexed Tree
- [ ] Square Root Decomposition
